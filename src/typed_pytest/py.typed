"""
Type stubs for typed-pytest.

This file provides IDE auto-completion support for TypedMock's dynamic attributes.
"""
from __future__ import annotations

from typing import Any, Generic, TypeVar

from typed_pytest._method import AsyncMockedMethod, MockedMethod

_T = TypeVar("_T")

class TypedMock(Generic[_T]):
    """Type-safe mock that preserves original type hints."""

    typed_class: type[_T] | None

    def __class_getitem__(cls, item: type[_T]) -> type[TypedMock[_T]]: ...

    if TYPE_CHECKING:
        def __getattr__(self, name: str) -> MockedMethod[..., Any] | AsyncMockedMethod[..., Any]: ...
    else:
        def __getattr__(self, name: str) -> Any: ...

    def __repr__(self) -> str: ...


def typed_mock(cls: type[_T], /, *, spec_set: bool = False, name: str | None = None, **kwargs: Any) -> TypedMock[_T]: ...


class TypedMocker:
    """Type-safe mocker wrapping pytest-mock's MockerFixture."""

    def __init__(self, mocker: Any) -> None: ...

    def mock(self, cls: type[_T], /, **kwargs: Any) -> TypedMock[_T]: ...

    def patch(
        self,
        target: str,
        new: type[_T] | None = None,
        **kwargs: Any,
    ) -> Any: ...

    def patch_object(
        self,
        target: object,
        attribute: str,
        new: type[_T] | None = None,
        **kwargs: Any,
    ) -> Any: ...

    def patch_dict(self, in_dict: dict[str, Any], /, **kwargs: Any) -> Any: ...

    def spy(self, obj: object, name: str) -> Any: ...


class MockedMethod(Generic[Any, Any]):
    """Mocked method wrapper preserving original signature."""

    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

    def assert_called(self) -> None: ...
    def assert_called_once(self) -> None: ...
    def assert_called_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_called_once_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_any_call(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_not_called(self) -> None: ...
    def assert_has_calls(self, calls: list[Any], any_order: bool = False) -> None: ...

    @property
    def return_value(self) -> Any: ...
    @return_value.setter
    def return_value(self, value: Any) -> None: ...

    @property
    def side_effect(self) -> Any: ...
    @side_effect.setter
    def side_effect(self, value: Any) -> None: ...

    @property
    def call_count(self) -> int: ...
    @property
    def called(self) -> bool: ...
    @property
    def call_args(self) -> Any: ...
    @property
    def call_args_list(self) -> list[Any]: ...

    def reset_mock(self) -> None: ...


class AsyncMockedMethod(Generic[Any, Any]):
    """Mocked async method wrapper."""

    async def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

    def assert_called(self) -> None: ...
    def assert_called_once(self) -> None: ...
    def assert_called_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_called_once_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_any_call(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_not_called(self) -> None: ...

    def assert_awaited(self) -> None: ...
    def assert_awaited_once(self) -> None: ...
    def assert_awaited_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_awaited_once_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_has_awaits(self, calls: list[Any], any_order: bool = False) -> None: ...

    @property
    def return_value(self) -> Any: ...
    @return_value.setter
    def return_value(self, value: Any) -> None: ...

    @property
    def side_effect(self) -> Any: ...
    @side_effect.setter
    def side_effect(self, value: Any) -> None: ...

    @property
    def call_count(self) -> int: ...
    @property
    def called(self) -> bool: ...
    @property
    def call_args(self) -> Any: ...
    @property
    def call_args_list(self) -> list[Any]: ...

    @property
    def await_count(self) -> int: ...
    @property
    def await_args(self) -> Any: ...
    @property
    def await_args_list(self) -> list[Any]: ...

    def reset_mock(self) -> None: ...


class MockProtocol:
    """Protocol for runtime mock compatibility checks."""
    def assert_called(self) -> None: ...
    def assert_called_once(self) -> None: ...
    def assert_called_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_called_once_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_any_call(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_not_called(self) -> None: ...

    @property
    def return_value(self) -> Any: ...
    @property
    def side_effect(self) -> Any | None: ...
    @property
    def call_count(self) -> int: ...
    @property
    def call_args(self) -> Any: ...
    @property
    def call_args_list(self) -> list[Any]: ...
    @property
    def called(self) -> bool: ...

    def reset_mock(self) -> None: ...


class AsyncMockProtocol(MockProtocol):
    """Protocol for async mock compatibility checks."""
    def assert_awaited(self) -> None: ...
    def assert_awaited_once(self) -> None: ...
    def assert_awaited_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_awaited_once_with(self, *args: Any, **kwargs: Any) -> None: ...

    @property
    def await_count(self) -> int: ...
    @property
    def await_args(self) -> Any: ...
    @property
    def await_args_list(self) -> list[Any]: ...


__version__: str
