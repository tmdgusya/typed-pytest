"""Template generation for typed-pytest-generator stubs."""

from __future__ import annotations

from typing import Any

from typed_pytest_generator._inspector import MethodInfo, format_signature_params

# Template for original class stub (for use with typed_mock())
ORIGINAL_CLASS_TEMPLATE = '''\
"""Auto-generated stub file for {class_name}.

Generated by typed-pytest-generator.
DO NOT EDIT MANUALLY.
"""

from __future__ import annotations

from typing import Any

{imports}

class {class_name}:
    """Original class stub for type checking."""

{methods}

# Alias for TypedMock subclass (convenience)
from typed_pytest import TypedMock

class {class_name}_TypedMock(TypedMock["{full_name}"]):
    """TypedMock stub with {class_name} method signatures."""

{methods_typed}

# Convenience alias
{class_name}Mock = {class_name}_TypedMock
'''

# Template for method stubs (original class)
ORIGINAL_METHOD_TEMPLATE = '''\
    def {name}(self, {params}) -> {return_type}: ...'''

ORIGINAL_ASYNC_METHOD_TEMPLATE = '''\
    async def {name}(self, {params}) -> {return_type}: ...'''

ORIGINAL_PROPERTY_TEMPLATE = '''\
    @property
    def {name}(self) -> {return_type}: ...'''

ORIGINAL_CLASSMETHOD_TEMPLATE = '''\
    @classmethod
    def {name}({params}) -> {return_type}: ...'''

ORIGINAL_STATICMETHOD_TEMPLATE = '''\
    @staticmethod
    def {name}({params}) -> {return_type}: ...'''

# Template for imports section
IMPORTS_TEMPLATE = '''\
import {module_name} as _orig_module
'''

# Template for method stubs
METHOD_TEMPLATE = '''\
    def {name}(self, {params}) -> MockedMethod[[{param_types}], {return_type}]: ...'''

ASYNC_METHOD_TEMPLATE = '''\
    async def {name}(self, {params}) -> AsyncMockedMethod[[{param_types}], {return_type}]: ...'''

PROPERTY_TEMPLATE = '''\
    @property
    def {name}(self) -> MockedProperty[{return_type}]: ...'''

CLASSMETHOD_TEMPLATE = '''\
    @classmethod
    def {name}({params}) -> MockedClassMethod[[{param_types}], {return_type}]: ...'''

STATICMETHOD_TEMPLATE = '''\
    @staticmethod
    def {name}({params}) -> MockedStaticMethod[[{param_types}], {return_type}]: ...'''


def _format_type(typ: Any) -> str:
    """Format a type annotation as a string."""
    if typ is None or typ == "Any" or typ is Any:
        return "Any"

    if hasattr(typ, "__name__"):
        return typ.__name__

    if hasattr(typ, "__origin__"):
        origin = typ.__origin__
        if hasattr(origin, "__name__"):
            args = ", ".join(_format_type(arg) for arg in typ.__args__)
            return f"{origin.__name__}[{args}]"

    return str(typ)


def _format_param_types(params: list) -> str:
    """Format parameters as type list for MockedMethod."""
    return ", ".join(_format_type(p.annotation) for p in params if p.annotation != "Any")


def _format_params(params: list) -> str:
    """Format parameters for method signature."""
    if not params:
        return ""

    param_strs = []
    for param in params:
        ann = _format_type(param.annotation)
        param_strs.append(f"{param.name}: {ann}")
    return ", ".join(param_strs)


def generate_class_stub(
    class_name: str,
    full_name: str,
    methods: list[MethodInfo],
) -> str:
    """Generate a .pyi stub for a single class.

    Args:
        class_name: Name of the class (e.g., "UserService")
        full_name: Fully qualified name (e.g., "mypkg.services.UserService")
        methods: List of MethodInfo objects

    Returns:
        Generated .pyi file content
    """
    # Extract module path for import
    module_name = full_name.rsplit(".", 1)[0] if "." in full_name else full_name

    # Generate method stubs for original class
    original_method_lines: list[str] = []
    # Generate method stubs for TypedMock subclass
    typed_method_lines: list[str] = []

    for method in methods:
        params = method.parameters
        params_str = _format_params(params)
        param_types = _format_param_types(params)
        return_type = _format_type(method.return_annotation)

        # Generate TypedMock method line (existing logic)
        if method.method_type == "async":
            typed_line = ASYNC_METHOD_TEMPLATE.format(
                name=method.name,
                params=params_str,
                param_types=param_types,
                return_type=return_type,
            )
            original_line = ORIGINAL_ASYNC_METHOD_TEMPLATE.format(
                name=method.name,
                params=params_str,
                return_type=return_type,
            )
        elif method.method_type == "property":
            typed_line = PROPERTY_TEMPLATE.format(
                name=method.name,
                return_type=return_type,
            )
            original_line = ORIGINAL_PROPERTY_TEMPLATE.format(
                name=method.name,
                return_type=return_type,
            )
        elif method.method_type == "classmethod":
            typed_line = CLASSMETHOD_TEMPLATE.format(
                name=method.name,
                params=params_str,
                param_types=param_types,
                return_type=return_type,
            )
            original_line = ORIGINAL_CLASSMETHOD_TEMPLATE.format(
                name=method.name,
                params=params_str,
                return_type=return_type,
            )
        elif method.method_type == "staticmethod":
            typed_line = STATICMETHOD_TEMPLATE.format(
                name=method.name,
                params=params_str,
                param_types=param_types,
                return_type=return_type,
            )
            original_line = ORIGINAL_STATICMETHOD_TEMPLATE.format(
                name=method.name,
                params=params_str,
                return_type=return_type,
            )
        else:  # regular method
            typed_line = METHOD_TEMPLATE.format(
                name=method.name,
                params=params_str,
                param_types=param_types,
                return_type=return_type,
            )
            original_line = ORIGINAL_METHOD_TEMPLATE.format(
                name=method.name,
                params=params_str,
                return_type=return_type,
            )

        original_method_lines.append(original_line)
        typed_method_lines.append(typed_line)

    # Generate import section
    imports = IMPORTS_TEMPLATE.format(module_name=module_name)

    # Generate the full stub with both original class and TypedMock
    return ORIGINAL_CLASS_TEMPLATE.format(
        class_name=class_name,
        full_name=full_name,
        imports=imports,
        methods="\n".join(original_method_lines),
        methods_typed="\n".join(typed_method_lines),
    )


def generate_init_stub(class_names: list[str]) -> str:
    """Generate __init__.pyi with exports.

    Args:
        class_names: List of class names that have stubs

    Returns:
        Generated __init__.pyi content
    """
    # Generate import statements
    imports = []
    exports = []

    for name in class_names:
        imports.append(f"from .{name} import {name}, {name}_TypedMock, {name}Mock")
        exports.append(f"    {name}")
        exports.append(f"    {name}_TypedMock")
        exports.append(f"    {name}Mock")

    return f'''\
"""Auto-generated TypedMock stubs for IDE auto-completion.

Generated by typed-pytest-generator.
DO NOT EDIT MANUALLY.
"""

from __future__ import annotations

{chr(10).join(imports)}

__all__ = [
{",\\n".join(exports)},
]
'''
